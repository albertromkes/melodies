# Psalm Melodies - Agent Guidelines

This document contains essential information for agentic coding agents working on this psalm melody notation application.

## Build & Development Commands

### Core Commands
- `npm run dev` - Start development server with hot reload
- `npm run build` - Build search index then create production build
- `npm run build:index` - Build only the search index (for data changes)
- `npm run preview` - Preview production build locally
- `npm run check` - Run type checking: `svelte-check` + `tsc` for node configs

### Data Generation Commands
- `.\generate-psalms.ps1 -PsalmNumber 23` - Generate single psalm JSON from ABC notation
- `.\generate-psalms.ps1 -PsalmRange 23-30` - Generate range of psalms
- Uses `psalm-melodys.txt` (ABC notation) and web scraping from elrenkema.nl
- Outputs to `src/lib/data/psalmen/psalm-{number}.json`
- Requires Node.js for Dutch syllabification (`syllabify-nl.js`)
- Automatically formats JSON output using `format-psalm.js` for readability

### Mobile Development (Capacitor)
- `npm run cap:sync` - Build web app and sync to native platforms
- `npm run cap:android` - Open Android project in Android Studio
- `npm run cap:ios` - Open iOS project in Xcode (macOS only)
- `npm run android:dev` - Build, sync, and run on Android device
- `npm run ios:dev` - Build, sync, and run on iOS simulator

### Testing
- **No automated tests** - Explicitly a non-goal per project requirements
- Manual testing required for musical correctness

## Tech Stack & Architecture

### Core Technologies
- **Frontend**: Svelte 5 with TypeScript
- **Music Libraries**: VexFlow (notation), Tonal.js (transposition)
- **Build**: Vite with Svelte plugin
- **Search**: MiniSearch
- **Mobile**: Capacitor (Android & iOS)
- **State**: Svelte 5 runes ($state, $derived, $effect)
- **Data**: JSON files generated from ABC notation + web scraping

### Project Structure
```
src/
├── lib/
│   ├── components/    # Svelte components
│   ├── data/         # Psalm JSON data (generated by PowerShell)
│   ├── types/        # TypeScript type definitions
│   └── utils/        # Utility functions (transposition, rendering)
├── App.svelte        # Main application
├── main.ts          # Entry point
└── app.css          # Global styles

Data Generation:
├── generate-psalms.ps1  # Main data generation script
├── syllabify-nl.js      # Dutch syllabification (Node.js)
├── format-psalm.js      # JSON formatting
└── psalm-melodys.txt    # ABC notation source
```

## Code Style Guidelines

### Svelte 5 Patterns
- **Always use Svelte 5 runes**: `$state()` for reactive state, `$derived.by()` for computed values, `$effect()` for side effects
- **Props destructuring**: Use `$props()` with explicit typing for component props
- **Event handlers**: Pass callback functions as props, not using Svelte event dispatching

### TypeScript Conventions
- **Strict typing everywhere**: All variables, functions, and components must have types
- **Import organization**: Group imports by type (external libraries, internal types, internal components, internal utilities)
- **Domain types**: Use proper music domain types from `src/lib/types/music.ts`
- **No `any` types**: Use specific types or `unknown` with proper type guards

### Naming Conventions
- **Components**: PascalCase (e.g., `PsalmDetail.svelte`, `StaffDisplay.svelte`)
- **Variables**: camelCase with domain clarity (e.g., `transposeSemitones`, `activeVerseNumber`)
- **Functions**: Verb-noun phrases describing action (e.g., `handleSelectSong`, `showGestureIndicator`)
- **Types**: PascalCase for interfaces/types, descriptive names (e.g., `PsalmData`, `NoteData`)

### File Organization
- **Barrel exports**: Use `export * from` in index files for clean imports
- **Component files**: Single component per file, matching filename
- **Type definitions**: Centralized in `src/lib/types/`
- **Utilities**: Organized by domain in `src/lib/utils/`

## Musical Domain Rules (CRITICAL)

### Musical Correctness First
- **Priority order**: 1. Musical correctness, 2. Simplicity, 3. Readability
- **Never hardcode music theory**: Always use Tonal.js for pitch manipulation
- **Defer to libraries**: Use VexFlow for notation, Tonal.js for transposition

### Melody & Transposition
- **Monophonic melodies**: Single note at a time, no chords
- **Chromatic transposition**: Semitone-based, unlimited range
- **Enharmonics**: Trust library defaults for correct spelling
- **Accidentals**: Handle through music library, not manual string manipulation

### Data Model Requirements
```typescript
// Core structure - NEVER deviate from this
interface PsalmData {
  id: string;
  number: number;
  title: string;
  category: string;           // "psalm", "gezang", etc.
  mode?: string;             // Musical mode description
  keySignature: string;       // "D", "G", "F", etc.
  timeSignature: [number, number]; // [beats, beatUnit]
  clef: string;              // "treble", "bass"
  melody: {
    measures: Measure[];     // Array of measures with notes
  };
  verses: VerseLyrics[];     // All verses with lyrics and syllables
}

interface NoteData {
  keys: string[];           // VexFlow format: ["a/4"], ["c#/5"]
  duration: string;         // w=whole, h=half, q=quarter, 8=eighth, 16=sixteenth
  rest?: boolean;          // If true, this is a rest
  accidental?: {           // Optional explicit accidental
    type: '#' | 'b' | 'n' | '##' | 'bb';
    cautionary?: boolean;  // Display in parentheses if true
  };
  syllable?: string;       // Syllable under note, "_" for melisma
}
```

## Import & Dependency Guidelines

### Library Usage Rules
- **Music theory**: ONLY use `tonal` package, no custom implementations
- **Notation**: ONLY use `vexflow` for staff rendering
- **Search**: Use `minisearch` for text search functionality
- **Mobile**: Use Capacitor APIs through `@capacitor/*` packages
- **Syllabification**: Dutch hyphenation via `hyphenation.nl` and `hypher`

### Import Organization Pattern
```typescript
// External libraries first
import { Note, Interval } from 'tonal';
import MiniSearch from 'minisearch';
import type { SomeExternalType } from 'external-lib';

// Internal types
import type { PsalmData, NoteData } from '../types/music';
import type { Category, SongMeta } from '../types';

// Internal components  
import StaffDisplay from './StaffDisplay.svelte';
import VerseSelector from './VerseSelector.svelte';

// Internal utilities
import { transposeNote } from '../utils/transposition';
import { renderStaff } from '../utils/vexflow-renderer';
```

## Data Generation Workflow

### Psalm Data Pipeline
1. **ABC Notation Source**: `psalm-melodys.txt` contains melodies in ABC format
2. **PowerShell Script**: `generate-psalms.ps1` orchestrates the entire conversion process
3. **Melody Parsing**: ABC → VexFlow format with proper key signatures and time signatures
4. **Verse Scraping**: Web scraping from elrenkema.nl for Dutch lyrics with HTML cleanup
5. **Syllabification**: Node.js script splits Dutch words into syllables with complex rules
6. **JSON Output**: Complete psalm data saved to `src/lib/data/psalmen/`

### Key Data Generation Concepts
- **ABC Notation**: Standard music notation format for melodies with keys like `K: D` and `M: 4/4`
- **Dutch Syllabification**: Complex rules for compound words, apostrophes, and accented vowels
- **Measure Alignment**: Syllables matched to note counts per measure (excluding rests)
- **Key Signature Handling**: Proper mapping of modes (dorian, phrygian, etc.) to major key signatures

### Running Data Generation
```powershell
# Single psalm
.\generate-psalms.ps1 -PsalmNumber 23

# Range of psalms  
.\generate-psalms.ps1 -PsalmRange 23-30

# After data changes, rebuild search index
npm run build:index
```

## Dutch Language Specifics

### Syllabification Rules
- **Compound words**: Special handling for Dutch compounds (e.g., "jammerstaat" → ["jam", "mer", "staat"])
- **Apostrophes**: Patterns for "d'", "m'", "'t" contractions (e.g., "d'oprechten" → ["d'op-", "rech-", "ten"])
- **Accented vowels**: Handle â, ê, ô, û characters in psalm text
- **Suffixes**: Common Dutch suffixes (-heid, -lijk, -ste, -nis, -sel, -ing)

### Text Processing
- **Web scraping**: Verses scraped from elrenkema.nl with comprehensive HTML cleanup
- **Word merging**: Handle Dutch prefixes (ge-, be-, ver-, ont-, her-, er-)
- **Musical alignment**: Syllables matched to note counts per measure with fallback rules

## Error Handling

### Musical Errors
- **Never fail silently**: Musical errors must surface to UI
- **Graceful degradation**: If transposition fails, show original key
- **User feedback**: Show clear messages for musical limitations

### Development Errors
- **Console warnings**: For failed data loads, use `console.warn()`
- **Type safety**: Let TypeScript catch errors at compile time
- **Runtime validation**: Validate external data (JSON files) on load

## Styling & Theming

### CSS Guidelines
- **CSS variables**: Use custom properties for theming
- **Component styles**: Scoped styles in `<style>` blocks
- **No inline styles**: Use CSS classes and variables
- **Mobile-first**: Design for mobile screens first

## Critical Reminders for Agents

1. **Musical correctness overrides all other concerns**
2. **Use established music libraries - never reinvent music theory**
3. **Maintain Svelte 5 rune patterns throughout**
4. **TypeScript strictness is mandatory**
5. **Keep code simple and explicit over clever**
6. **Every change should preserve musical accuracy**
7. **Test transposition thoroughly - it's a core feature**
8. **Mobile compatibility is essential**
9. **Dutch syllabification is complex - use Node.js script**
10. **Data generation requires PowerShell + Node.js environment**

This application prioritizes musical correctness and simplicity over feature completeness. The data generation pipeline is sophisticated and handles complex rules of Dutch syllabification for psalmody.